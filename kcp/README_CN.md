# kcp协议库

#### 概述
官网介绍
```
KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据的发送方式，以 callback的方式提供给 KCP。连时钟都需要外部传递进来，内部不会有任何一次系统调用。
TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。
```

#### KCP结构
0               4   5   6       8 (BYTE)
+---------------+---+---+-------+
|     conv      |cmd|frg|  wnd  |
+---------------+---+---+-------+   8
|     ts        |     sn        |
+---------------+---------------+  16
|     una       |     len       |
+---------------+---------------+  24
|                               |
|        DATA (optional)        |
|                               |
+-------------------------------+
解析:
1:(4BYTE) conv 双方协商的唯一识别码, 收发端一致
2:(1BYTE) cmd 报文段类型,IKCP_CMD_PUSH, IKCP_CMD_ACK, IKCP_CMD_WASK, IKCP_CMD_WINS
3:(1BYTE) frg 剩余包的分片数量, 这个包之后还有多少个报文属于这个包
4:(2BYTE) wnd 发送方剩余接收窗口大小
5:(4BYTE) ts 发送时间戳,用来计算RTT(往返时间), 然后计算出RTO(超时重传时间)
6:(4BYTE) sn 报文编号,唯一标识报文
7:(4BYTE) una 发送方接收缓冲区还未接收的最小报文段编号
8:(4BYTE) len 后面的数据长度
9:(大小根据len决定) data 传输的数据, 数据报文才有这个字段

#### 目标
本来已经有golang版本的kcp了, 但是代码比原版多了很多,所以干脆直接仿照原版写一个golang版本的

#### 改进
现在因为源码是c语言,所以错误判断都是在代码中以assert的形式展现的,golang后面会统一在函数返回的时候加入error判断
